<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>one2twenty VR/AR</title>
</head>
<body style="margin: 0; background-color: #888888;">

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
{
	"imports": {
		"three": "https://code4fukui.github.io/three.js/build/three.module.js",
		"three/addons/": "https://code4fukui.github.io/three.js/examples/jsm/"
	}
}
</script>

<script type="module">
import * as THREE from "three";
import { AR } from "./AR.mjs";
import { createTextMesh } from "./createTextMesh.mjs";
import { sleep } from "https://js.sabae.cc/sleep.js";
import { SoundSystem } from "./SoundSystem.mjs";

export const createNumSphere = (num, size) => {
  const g = new THREE.Group();
  const geo = new THREE.SphereGeometry(size, 15, 32);
  //const color = 0xff0000;
  const color = 0xffffff;
  const mat = new THREE.MeshBasicMaterial({ color, opacity: 0.4, transparent: true });
  const mesh = new THREE.Mesh(geo, mat);
  g.add(mesh);
  const txt = createTextMesh("" + num, 0, 0, 0, 0xffffff);
  g.add(txt);
  return g;
};

export const createNumSphere2 = (size) => {
  const g = new THREE.Group();
  const geo = new THREE.SphereGeometry(size, 15, 32);
  //const color = 0xff0000;
  const color = 0xFF0000;
  const mat = new THREE.MeshBasicMaterial({ color, opacity: 0.4, transparent: true });
  const mesh = new THREE.Mesh(geo, mat);
  g.add(mesh);
  const txt = createTextMesh("X" , 0, 0, 0, 0xFF0000);
  g.add(txt);
  return g;
};

class One2Twenty extends AR {
  async main() {
    // test geometry
    /*
    const geo = new THREE.SphereGeometry(1, 64, 20);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0, 0, -5);
    this.scene.add(mesh);
    */

    const ss = new SoundSystem("sound/", ["start", "pon", "clear", "success", "decide", "bubu", "levelselect", "nomal", "hard", "veryhard", "nexttime"]);
    const levellist = ["nomal", "hard", "veryHard"];

    
    let besttime = 0;
    let lasttime1 = 0;
    let lasttime2 = 0;
    let lasttime3 = 0;
    let lasttime = 0;
    let cleartime = 0;
    for (;;) {
      let besttime1 = parseFloat(localStorage.getItem("besttime1")) || 100;
      let besttime2 = parseFloat(localStorage.getItem("besttime2")) || 100;
      let besttime3 = parseFloat(localStorage.getItem("besttime3")) || 100;
      const tz = -1.5;
      const title = new THREE.Group();
      title.add(createTextMesh("one to twenty", 0, 0.4, tz));

      this.scene.add(title);

      //await sleep(1000);
      await this.waitSelect();
      ss.play("levelselect");

      this.scene.remove(title);

      const ns = 20;
      let ns2 = 0;
      const size = 0.1;
      const objs = [];
      this.objs = objs;
      const objs2 = [];
      this.objs2 = objs2;
      const pnt = [];
      const pnt2 = [];
      const rndw = 1.2;
      let level = 0;
      
      const levelselect = new THREE.Group();
      levelselect.add(createTextMesh("1:nomal            *0", 0, 1.0, tz));
      levelselect.add(createTextMesh("2:hard             *20", 0, 0.7, tz));
      levelselect.add(createTextMesh("3:veryHard         *40", 0, 0.4, tz));
      this.scene.add(levelselect);

      for (let i = 0; i < 3; i++) {
        const x = (-1 + i);
        const y = -0.2;
        const z = -1;
        const p = new THREE.Vector3(x, y, z);
        let flg = false;
        for (let j = 0; j < pnt.length; j++) {
          if (pnt[j].distanceTo(p) < size * 2) {
            flg = true;
            break;
          }
        }
        if (flg) {
          i--;
          continue;
        }
        pnt[i] = p;

        const obj = createNumSphere(i + 1, size);
        obj.position.copy(p);
        this.scene.add(obj);
        objs.push(obj);
      }

      for (let i = 0; i < 3; i++) {
        const x = 0.15;
        const y = 1.0 - 0.3 * i;
        const z = tz;
        const q = new THREE.Vector3(x, y, z);
        let flg = false;
        for (let j = 0; j < pnt2.length; j++) {
          if (pnt2[j].distanceTo(q) < size * 2) {
            flg = true;
            break;
          }
        }
        if (flg) {
          i--;
          continue;
        }
        pnt2[i] = q;

        const obj2 = createNumSphere2(size);
        obj2.position.copy(q);
        this.scene.add(obj2);
        objs2[i] = obj2;
      }

      B: for (;;) {
        await sleep(1000 / 60);
        for (let i = 0; i < this.ctrls.length; i++) {
            const ctrl = this.ctrls[i];
            const hp = new THREE.Vector3();
            hp.setFromMatrixPosition(ctrl.matrixWorld);
            for (let j = 0; j < pnt.length; j++) {
              let e = hp.distanceTo(pnt[j]);
              if (e <= size * 1.2) {
                level = j + 1;
                this.scene.remove(levelselect);
                break B;
              }
            }
        }
      }
      for (let j = 0; j < pnt.length; j++) {
        this.scene.remove(objs[j]);
        this.scene.remove(objs2[j]);
      }
      pnt2.splice(0);
      switch (level) {
        case 1:
          ns2 = 0;
          besttime = besttime1;
          lasttime = lasttime1;
          ss.play("nomal");
          break;
        case 2:
          ns2 = 20;
          besttime = besttime2;
          lasttime = lasttime2;
          ss.play("hard");
          break;
        case 3:
          ns2 = 40;
          besttime = besttime3;
          lasttime = lasttime3;
          ss.play("veryhard");
          break;
      }
      const choice = new THREE.Group();
      choice.add(createTextMesh(levellist[level-1], 0, 1.0, tz));
      choice.add(createTextMesh("best time: " + besttime.toFixed(2) + "sec", 0, 0.7, tz));
      choice.add(createTextMesh("latest time: " + (lasttime ? lasttime.toFixed(2) : "-") + "sec", 0, 0.4, tz));
      this.scene.add(choice);
      await this.waitSelect();
      

      this.scene.remove(choice);
      ss.play("start");

      for (let i = 0; i < ns; i++) {
        const x = Math.random() * rndw - rndw / 2;
        const y = Math.random() * rndw * .7 - .6;
        const z = Math.random() * rndw - 2.0;
        const p = new THREE.Vector3(x, y, z);
        let flg = false;
        for (let j = 0; j < pnt.length; j++) {
          if (pnt[j].distanceTo(p) < size * 2) {
            flg = true;
            break;
          }
        }
        if (flg) {
          i--;
          continue;
        }
        pnt[i] = p;

        const obj = createNumSphere(i + 1, size);
        obj.position.copy(p);
        this.scene.add(obj);
        objs[i] = obj;
      }

      for (let i = 0; i < ns2; i++) {
        const x = Math.random() * rndw - rndw / 2;
        const y = Math.random() * rndw * .7 - .6;
        const z = Math.random() * rndw - 2.0;
        const q = new THREE.Vector3(x, y, z);
        let flg = false;
        for (let j = 0; j < pnt2.length; j++) {
          if (pnt2[j].distanceTo(q) < size * 2) {
            flg = true;
            break;
          }
        }
        if (flg) {
          i--;
          continue;
        }
        pnt2[i] = q;

        const obj2 = createNumSphere2(size);
        obj2.position.copy(q);
        this.scene.add(obj2);
        objs2[i] = obj2;
      }

      let cnt = 0;
      let cnt2 = 0; 
      const startt = new Date().getTime();

      // debug
      let debugmesh = null;
      const debug = (s) => {
        if (debugmesh) {
          this.scene.remove(debugmesh);
        }
        debugmesh = createTextMesh(s, 0, 1.5, tz);
        this.scene.add(debugmesh);
      };

      // game
      A: for (;;) {
        await sleep(1000 / 60);
        for (let i = 0; i < this.ctrls.length; i++) {
          const count = new THREE.Vector3(x, y, z);
          count.add(createTextMesh("next:" + cnt, 0, 0.4, 2));
	  this.scene.add(count);
          const ctrl = this.ctrls[i];
          const hp = new THREE.Vector3();
          hp.setFromMatrixPosition(ctrl.matrixWorld);
          const d = hp.distanceTo(pnt[cnt]);
          for (let j = 0; j < pnt2.length; j++) {
            let e = hp.distanceTo(pnt2[j]);
            if (e <= size * 1.2) {
              this.scene.remove(objs2[j]);
              objs2.splice(j, 1);
              pnt2.splice(j, 1);
              ss.play("bubu");
              cnt2++;
            }
          }
          
          if (d <= size * 1.2) {
            this.scene.remove(objs[cnt]);
            ss.play("pon");
            cnt++;
            if (cnt == ns) {
              for (let j = 0; j < pnt2.length; j++) {
                this.scene.remove(objs2[j]);
              }
              ss.play("clear");
              cleartime = (new Date().getTime() - startt) / 1000;
              lasttime = cleartime + cnt2 * 5;
              const result = new THREE.Group();
              result.add(createTextMesh("CLEAR! ", 0, 1.3, tz));
              result.add(createTextMesh("clear time: " + cleartime.toFixed(2) + "sec", 0, 1.0, tz));
              result.add(createTextMesh("miss: " + cnt2 + " * 5sec", 0, 0.7, tz, 0xFF0000));
              result.add(createTextMesh("result time: " + lasttime.toFixed(2) + "sec", 0, 0.4, tz));
              this.scene.add(result);
              await sleep(1000);
              await this.waitSelect();
              this.scene.remove(result);

              let mes = null;
              if (lasttime < besttime) {
                besttime = lasttime;
                mes = "HIGH SCORE! " + lasttime.toFixed(2) + "sec";
                ss.play("success");
              } else {
                mes = "Let's do our best next time!! ";
                ss.play("nexttime");
              }
              switch (level) {
                  case 1:
                    localStorage.setItem("besttime1", besttime);
                    lasttime1 = lasttime;
                    break;
                  case 2:
                    localStorage.setItem("besttime2", besttime);
                    lasttime2 = lasttime;
                    break;
                  case 3:
                    localStorage.setItem("besttime3", besttime);
                    lasttime3 = lasttime;
                    break;
              }
              const meshm = createTextMesh(mes, 0, 1.0, tz);
              this.scene.add(meshm);
              await sleep(1000);
              await this.waitSelect();
              ss.play("decide");
              this.scene.remove(meshm);
              break A;
            }
          }
        }
      }
    }
    // clear
  }
  loop() {
    if (!this.objs) return;
    for (let i = 0; i < this.objs.length; i++) {
      this.objs[i].rotation.y += 0.01;
    }
  }
}

await new One2Twenty().init();

</script>
</body>
</html>
